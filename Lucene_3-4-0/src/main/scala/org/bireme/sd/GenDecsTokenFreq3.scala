package org.bireme.sd

import java.text.Normalizer
import java.text.Normalizer.Form
import java.io.File
import java.nio.charset.Charset

import collection.JavaConverters._

import org.apache.lucene.analysis.WhitespaceAnalyzer
import org.apache.lucene.document.{Document,Field,NumericField}
import org.apache.lucene.index.{IndexReader,IndexWriter,IndexWriterConfig,Term}
import org.apache.lucene.store.FSDirectory
import org.apache.lucene.util.Version

import scala.io.Source

object GenDecsTokenFreq3 extends App {
  val separators = """[\d\s\,\.\-;\"\=\<\>\$\&\:\+\%\*\@\?\!\~\^\(\)\[\]`'/Â¿#_]"""

  private def usage(): Unit = {
    Console.err.println("description: Given a decs token file " +
      "(generated by 'geraDescritoresPipe.sh' shell) and some Lucene document " +
      "fields, creates an frequency index associating each decs token to " +
      "the number of times it appears in the given index.")
    Console.err.println()
    Console.err.println("usage: GenDecsTokenFreq3 <decsInFile> <decsEncoding> " +
                        "<inIndexPath> <field1>,<fields2>,..,<fieldN> " +
                        "<freqIndexPath>")
    System.exit(1)
  }

  if (args.length != 5) usage()

  gener(args(0), args(1), args(2), args(3).split("\\,").toSet, args(4))


  def gener(decsInFile: String,
            decsEncoding: String,
            inIndex: String,
            fldNames: Set[String],
            outIndex: String): Unit = {
    val in = Source.fromFile(decsInFile, decsEncoding)
    val analyzer = new WhitespaceAnalyzer(Version.LUCENE_34)
    val config = new IndexWriterConfig(Version.LUCENE_34, analyzer)
    val inDir = FSDirectory.open(new File(inIndex))
    val inReader = IndexReader.open(inDir);
    val outDir = FSDirectory.open(new File(outIndex))
    val outWriter = new IndexWriter(outDir, config)
    val set = in.getLines().zipWithIndex.
                                     foldLeft[Set[(String,String,Int)]](Set()) {
      case (st, (line,pos)) => {
        if (pos % 10000 == 0) println(s"decs-$pos")
        val split = line.split("\\|", 3)
        uniformString(split(2)).split(separators).
                                        foldLeft[Set[(String,String,Int)]](st) {
          case (st2, word) => {
            val word2 = word.trim
            if (word2.isEmpty) st2 else {
              val qtt = fldNames.foldLeft[Int](0) {
                case (qt,fld) => qt + inReader.docFreq(new Term(fld, word2))
              }
              st2 + ((split(1),word2,qtt))
            }
          }
        }
      }
    }
    set.foreach {
      case (id,word,qtt) => {
        val doc = new Document()
        doc.add(new Field("dbname", "decs", Field.Store.YES, Field.Index.NOT_ANALYZED))
        doc.add(new Field("id", id, Field.Store.YES, Field.Index.NOT_ANALYZED))
        doc.add(new NumericField("freq", Field.Store.YES, false).setIntValue(qtt))
        doc.add(new Field("token", word, Field.Store.YES,  Field.Index.ANALYZED))
        outWriter.addDocument(doc);
      }
    }

    print("Optimizing index ...")
    outWriter.optimize()
    outWriter.close()
    outDir.close()
    println("Ok")

    in.close()
    inReader.close()
    inDir.close()
  }

  private def uniformString(in: String): String = {
    val s = Normalizer.normalize(in.toLowerCase(), Form.NFD)
    s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "")
  }

}
